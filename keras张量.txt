0维张量
import numpy as np
x=np.array(12)
#np把数字作为0维度
x.ndim
#?会出来用法文档
# np.array?
1维张量
x=np.array([12,22,26])
x
#np把一维数组作为1维,就是tensor的1维向量
x.ndim
x.shape
2维张量
x=np.array([[12,21,11],[22,11,6]])
#形状里有几个,分开的数字代表几个坐标轴
#也就代表几维,里面的数字代表在某个轴上的数字
display(x.shape,x.ndim)
3维张量
#3维就是把二维矩阵当成元素,一个个排一排
#写的时候可以先写一维,一维就是0维数字排一排
#,二维就是把1维当成数字排一排,三维也一样
#识别办法,最外层的中括号数代表最高维数
#每进一层就少一个中括号,依次把里面的维度
#当成一个元素就行.可以理解成,集合里面套集合
#只不过每一次都把内层集合当成元素了
x=np.array([[[1,2,3],[3,4,5]],
            [[11,2,32],[35,4,56]],
           [[1,2,3],[3,4,5]]
           ])
#可以把三维shape想成有3个2x3的矩阵
display(x.ndim,x.shape)
4维和更高维
#代表有3个三维元素,每个三维内部有两个2*4的矩阵
x=np.random.randint(0,10,size=(3,2,2,4))
x
display(x.shape,x.ndim)
#如何看高维,从外往里看中括号,最外边中括号个数
#代表最高维度,往里依次递减,比如最外边5个,那就
#看其中元素在4个中括号之间的那堆东西,就是一个
#4维,找一个4维里的3维,就单拎出来一个4维,看里面
#3个中括号之间的东西
x=np.random.randint(30,size=(3,2,3,3,5))
x
display(x.shape,x.ndim)
x=np.random.random(size=(4,5))*10
#广播机制,y缺x轴,被复制了4份
y=np.random.random(5)*10
display(x,y,np.maximum(x,y))
x=np.random.randint(30,size=(3,2,2,4))
#y被广播,缺0,1轴,(2,4)先被复制一份
#之后形成的3维又被复制2份
y=np.random.randint(30,size=(2,4))
display(x,y,np.maximum(x,y))
x=np.random.randint(30,size=(2,4))
#axis=0代表我们数学里空间直角坐标系的x轴
#但维度钥匙高了就无法只用x,y,z表示,所以
#就用0,1,2,3...表示轴
#按编号0的轴做和,ndarray里编号0的轴就是列那个方向
y=x.sum(axis=0)
#y被广播,缺0轴,就被复制一份,之后再对应元素相除
z=x/y
display(x,y,z)
向量的点乘
z=x/y
x=np.random.randint(5,size=3)
y=np.random.randint(5,size=3)
z=np.dot(x,y)
display(x,y,z)
x=np.random.randint(5,size=(2,3))
y=np.random.randint(5,size=(3))
#形状不一样,内积,匹配向量做内积
#就是把矩阵每一行当成向量去和y内积
z=np.dot(x,y)
display(x,y,z,z.ndim)
x=np.random.randint(5,size=(3,2,2,4))
#最重要的思想是把里面的(2,4)当成矩阵
#是对应矩阵运算,之后高维的就是几个
#矩阵运算,最里面的矩阵一定要中间相等取两头
y=np.random.randint(5,size=(4,2))
z=np.dot(x,y)
display(x,y,z,z.shape)
x=np.random.randint(5,size=(3,2,2,4))
#最重要的思想是把里面的(2,4)当成矩阵
#是对应矩阵运算,之后高维的就是几个
#矩阵运算,最里面的矩阵一定要中间相等取两头
#size=(4)直接把它看成(4,1)矩阵就行了
y=np.random.randint(5,size=(4))
z=np.dot(x,y)
display(x,y,z,z.shape)
a=np.random.randint(5,size=(3,2,3))
#-1代表自匹配,确定的就是3,其他的会自动变形
#但无论如何变,size不会变
b=a.reshape(3,-1)
display(a,b)
张量的转换
x=np.zeros((300,20))
y=np.transpose(x)
#转置
display(x.shape,y.shape,x.T.shape)
x=np.random.randint(5,size=(3,50,5,8))
#高维转置就是形状倒过来
y=x.T
display(x.shape,y.shape)
x=np.arange(24)
#无论如何变形,里面总元素个数不变
#2*3*4==24
y=x.reshape(2,3,4)
#1对应的位置是(0,0,1),转置后应该是(1,0,0)
#千万不能弄重复的元素,不然会很乱,arange能保证不重复
#转置就是形状倒过来,那在原来张量里的元素的
#位置倒过来就能在转置后的矩阵里找到
#比方说20在原张量里是(1,2,0),转置后应该是(0,2,1)
display(x.shape,x,y,y.shape)
#果然在转置后的(0,2,1)找到了它
#一定要把每个维的数都看成编号从0开始
#之后在对应轴上依次排
z=y.T
z
x=np.arange(12)
y=x.reshape(2,2,3)
#因为有很多维,用x,y,z轴来表示不合适,所以用编号表示
#这里指定转换后编号0的轴还是原来编号0的轴,
#编号1的轴是原来编号2的轴,编号2的轴轴是原来编号1的轴
#原来2x3矩阵变成3x2
#原来(0,0,1)的元素1在编号0的轴
#不变时,转置后是(0,1,0)
#果然对应转置后的(0,1,0)位置
z=np.transpose(y,(0,2,1))
display(x,y,z)
